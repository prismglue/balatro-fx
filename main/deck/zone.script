go.property("hand_size", 8) -- make cards 'larger' so they space out better

local CARD_LEAVE_INTERVAL = 0.07

function init(self)
	-- get the total size of the zone
	self.zone_size = go.get('#sprite', 'size')
	print("ZoneSize: " .. self.zone_size)
	
	-- get the total size of a card
	self.card_size = go.get('/card_img#sprite', 'size')
	self.half_card = self.card_size.x/2
	print("CardSize: " .. self.card_size)

	--self.hand_size = 8 -- increases and decreases on gameplay events
	self.card_count = 0 -- lua doesn't know how many items are in a table and doesn't offer a builtin for counting
	-- you can be overdealt and your hand can be larger than hand_size, so it's math.max between them
	self.cards = {}
end

function update(self, dt)
end

function fixed_update(self, dt)
end

local function get_selected_cards(self)
	local selectcount = 0
	local selected = {}
	local mypos = go.get_position()
	for i, card in next, self.cards do
		local pos = go.get_position(card.url)
		-- don't bother with 'card_select' messages, just find out if it's away from the baseline, heh
		if card.selected or mypos.y ~= pos.y then
			selectcount = selectcount + 1
			selected[selectcount] = card
		end
	end
	return selected, selectcount
end

local function get_card_space(self, size)
	local total_cards = math.max(self.hand_size, self.card_count)
	return size / total_cards, total_cards
end

local function animate_remove(self, removed)
	-- it's actually relatively simple
	-- for each card, move all the cards towards the empty spot in a leftofremove/rightofremove fashion
	local x_start = go.get_position().x - (self.zone_size.x/2)
	local x_end = go.get_position().x + (self.zone_size.x/2)
	local removed_urls = {}
	for i, remove in next, removed do
		self.card_count = self.card_count - 1
		local space_per_card = get_card_space(self, x_end-x_start)
		local reali = 0
		removed_urls[remove.url] = remove
		local remove_index = 0
		for ci, card in next, self.cards do
			if removed_urls[card.url] == nil then
				local delay = CARD_LEAVE_INTERVAL*(i-1)
				-- card's current position is irrelevant, tell it where it's going
				local emptyslots = self.hand_size-self.card_count
				local x = (space_per_card * reali) + self.half_card + (emptyslots*(space_per_card/2))
				local orig = go.get_position(card.url).x
				-- x is offset by card space for every missing card
				reali = reali + 1
				print('animating ' .. card.url .. ' to a new x position? ' .. x .. " esd: " .. emptyslots)
				go.animate(card.url, 'position.x', go.PLAYBACK_ONCE_FORWARD, x, go.EASING_LINEAR, CARD_LEAVE_INTERVAL, delay)
			elseif card.url == remove.url then
				remove_index = ci
			end
		end
		print("removed " .. table.remove(self.cards, remove_index).url)
	end
end

function on_message(self, message_id, message, sender)
	-- I need to know when I'm about to receive a card, and what suit it is, so I can pick a slot for it and reply
	if message_id == hash("card_announce") then
		-- high->low suits is spades, hearts, diamonds, clubs
		-- 14 is ace, 13 king, 12 queen, 11 jack, then regular numberwang
		--message.value 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2
		--message.suit  0 (spade), 1 (heart), 2 (diamond), 3 (club)
		local x_start = go.get_position().x - (self.zone_size.x/2)
		local x_end = go.get_position().x + (self.zone_size.x/2)
		local space_per_card, total_cards = get_card_space(self, (x_end-x_start))

		local total_bounds = 0 -- this shrinks... relative to hand size... i think i'm going to call variable sizes a 'stretch goal' (i.e. i'm too lazy)
		local pos = go.get_position()
		local new_card_pos = vmath.vector3((space_per_card * self.card_count) + self.half_card, pos.y, pos.z)
		
		print("Bound start: " .. x_start .. " / " .. x_end .. " total: " .. total_cards .. " space per card " .. space_per_card .. " location: " .. new_card_pos)
		self.card_count = self.card_count + 1
		self.cards[self.card_count] = { url = message.url }
		pprint(self.cards)
		msg.post(sender, "zone_offer", { url = message.url, target = new_card_pos })
	elseif message_id == hash("zone_offer") then
		print("ZONE OFFER")
		pprint(message)
		msg.post(message.url, 'fling', { target = message.target })
	elseif message_id == hash('card_select') then
		for i, card in next, self.cards do
			if card.url == sender then
				card.selected = not card.selected
			end
		end
	elseif message_id == hash('discard') then
		local selected, selected_count = get_selected_cards(self)
		pprint(selected)
		-- throw these cards away index by index with a delay offset by the iteration... anyway
		self.discard_pos = go.get_position('/discard_pile')
		for i, remove in next, selected do
			msg.post(remove.url, 'fling', { target = self.discard_pos, delay = CARD_LEAVE_INTERVAL*(i-1)})
		end
		-- shuffle cards together
		animate_remove(self, selected)
	elseif message_id == hash('play') then
		local selected, selected_count = get_selected_cards(self)
		pprint(selected)
		-- announce these to the play_zone
		for i, card in next, selected do
			msg.post('/play_zone', "card_announce", {url = card.url})
		end
		-- shuffle cards together
		animate_remove(self, selected)
	end
end

-- mouseover is what triggers shuffles - if you mouse over another card while dragging a primary card, trigger the shift right
-- mouseover doesn't work, i move some of the items too high
-- i have two options
-- create a collisionobject for each card slot
-- monitor drag events for card slot overlap
-- seems like drag events would be cheaper, we're already getting them every frame

-- drag event timestamp: https://youtu.be/bFOfsbmB2O4?t=1275


-- in balatro, cards get spaced based on the expected hand size. so when you discard cards, they don't change their relative distance...
-- unless you have been over-dealt, then when your card leaves, the overdealt hand shrinks

-- the tilt of the card is relative to it's position - 5 in a 9 card hand faces straight up

-- i guess the final trouble is the 'float around the centre' behaviour. cards float towards the centre
-- ok so you deal 4 / 8 cards, you only have 4 left. they push each other together, hmm...

-- you could shrink the total available board area around the centre point?
-- that way, everything is still positioned relative to the centre, but the maximum bounds are redefined
-- like a hand-sized-hole that grows based on the total number of cards. then you divide the consumed space across the card sized hole.

-- cards are 'served' in order they are drawn but they place themselves in rank/suit order
-- so 5 can be dealt then 2, 5 will go left, 2 will go right
-- knowing all card positions in advance would help such an animation since cards know their final position
-- i don't think this happens though, i think it acts like the single card join animation
-- s the card lands in it's spot, it shoves the other cards left and right

-- https://www.youtube.com/watch?v=bFOfsbmB2O4 this video has a fat hand and a few hours of gameplay to scrub through for details

-- ah we need a slot system
-- slots should exist based on the number of dealt cards
-- how do you drag between each slot? triggers?

