function init(self)
	-- get the total size of the zone
	self.zone_size = go.get('#sprite', 'size')
	print("ZoneSize: " .. self.zone_size)
	
	-- get the total size of a card
	self.card_size = go.get('/card_img#sprite', 'size')
	self.half_card = self.card_size.x/2
	print("CardSize: " .. self.card_size)

	self.hand_size = 8 -- increases and decreases on gameplay events
	self.card_count = 0 -- lua doesn't know how many items are in a table and doesn't offer a builtin for counting
	-- you can be overdealt and your hand can be larger than hand_size, so it's math.max between them
	self.cards = {}
end

function update(self, dt)
end

function fixed_update(self, dt)
end

local function get_selected_cards(self)
	local selectcount = 0
	local selected = {}
	local mypos = go.get_position()
	for i, card in next, self.cards do
		pos = go.get_position(card.url)
		-- don't bother with 'card_select' messages, just find out if it's away from the baseline, heh
		if card.selected or mypos.y ~= pos.y then
			selectcount = selectcount + 1
			selected[selectcount] = card
		end
	end
	return selected
end

function on_message(self, message_id, message, sender)
	-- I need to know when I'm about to receive a card, and what suit it is, so I can pick a slot for it and reply
	if message_id == hash("card_announce") then
		-- high->low suits is spades, hearts, diamonds, clubs
		-- 14 is ace, 13 king, 12 queen, 11 jack, then regular numberwang
		--message.value 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2
		--message.suit  0 (spade), 1 (heart), 2 (diamond), 3 (club)
		local x_start = go.get_position().x - (self.zone_size.x/2)
		local x_end = go.get_position().x + (self.zone_size.x/2)
		local total_cards = math.max(self.hand_size, self.card_count)
		local space_per_card = (x_end-x_start) / total_cards

		local total_bounds = 0 -- this shrinks... relative to hand size... i think i'm going to call variable sizes a 'stretch goal' (i.e. i'm too lazy)
		local pos = go.get_position()
		local new_card_pos = vmath.vector3((space_per_card * self.card_count) + self.half_card, pos.y, pos.z)
		
		print("Bound start: " .. x_start .. " / " .. x_end .. " total: " .. total_cards .. " space per card " .. space_per_card .. " location: " .. new_card_pos)
		self.card_count = self.card_count + 1
		self.cards[self.card_count] = { url = message.url }
		pprint(self.cards)
		msg.post(sender, "zone_offer", { url = message.url, target = new_card_pos })
	elseif message_id == hash('card_select') then
		for i, card in next, self.cards do
			if card.url == sender then
				card.selected = not card.selected
			end
		end
	elseif message_id == hash('discard') then
		local selected = get_selected_cards(self)
		pprint(selected)
		-- throw these cards away index by index with a delay offset by the iteration... anyway
		for i, card in next, selected do
			msg.post(card.url, 'discard')
		end
	elseif message_id == hash('play') then
		local selected = get_selected_cards(self)
		pprint(selected)
	end
end

-- in balatro, cards get spaced based on the expected hand size. so when you discard cards, they don't change their relative distance...
-- unless you have been over-dealt, then when your card leaves, the overdealt hand shrinks

-- the tilt of the card is relative to it's position - 5 in a 9 card hand faces straight up

-- i guess the final trouble is the 'float around the centre' behaviour. cards float towards the centre
-- ok so you deal 4 / 8 cards, you only have 4 left. they push each other together, hmm...

-- you could shrink the total available board area around the centre point?
-- that way, everything is still positioned relative to the centre, but the maximum bounds are redefined
-- like a hand-sized-hole that grows based on the total number of cards. then you divide the consumed space across the card sized hole.

-- cards are 'served' in order they are drawn but they place themselves in rank/suit order
-- so 5 can be dealt then 2, 5 will go left, 2 will go right
-- knowing all card positions in advance would help such an animation since cards know their final position
-- i don't think this happens though, i think it acts like the single card join animation
-- s the card lands in it's spot, it shoves the other cards left and right

-- https://www.youtube.com/watch?v=bFOfsbmB2O4 this video has a fat hand and a few hours of gameplay to scrub through for details

